
from plone.app.learning.behaviors import IMachineLearning
from plone.app.learning.interfaces import ILearningString
from plone.app.learning.machinelearning.utils.base import CatalogEmpty
from plone.app.learning.machinelearning.persistence import save_model, load_model
from plone.app.learning.machinelearning.utils.clustering import (
		clustering_model, clustering_top_terms
		)



class Clustering(object):
    """
    Computes clustering for objects with IClustering schema

    :iparam context: Any object (for obtaining portal_catalog, etc.)
    :iparam schema: An abb.learning.settings.ISettings registry proxy
    :iparam learned_objs: The list of objects learned (by order of learning)
    """

    def __init__(self,context, schema):
        self.context = context
        self.schema = schema
        self.learned_objs = []


    def compute(self,vectorizer,objs,corpus):
    	model = clustering_model(corpus,n_clusters=self.schema.nClusters)
    	#Parametres del model
    	nclust, nfeatures = model.cluster_centers_.shape

    	#Refresh cluster objects
    	self._update_objects_labels(objs,model.labels_)

        #store model
       	self._persist_model(model)
        self._update_topterms(model,vectorizer)

     	r = "Clustering. Clusters: {}"
    	return r.format(nclust)

    def _update_objects_labels(self,objs,labels):
    	"""
    	Update cluster labels for each object
    	"""
    	for ob,lbl in zip(objs,labels):
    		ILearningString(ob).setClusterGroup(lbl)

    def _persist_model(self,model):
    	#Model pickle
        save_model(model,self.schema.modelsDir,self.schema.clusteringFile)
        
 
    def predict(self, corpus):
    	model = load_model(self.schema.modelsDir,self.schema.clusteringFile)
    	return model.predict(corpus)


    def _update_topterms(self,model,vectorizer):
        #If not cheked remembering, there is no human vocabulary
        if self.schema.useRemembering:
            self.schema.clustersTerms = clustering_top_terms(model,vectorizer)


    def _iterator_catalog_related_objects(self,clustid):
        catalog = getToolByName(self.context, 'portal_catalog')
        related = catalog({
            'object_provides': IMachineLearning.__identifier__,
            'MachineLearning-ClusterGroup': str(clustid) })

        if not related:
            raise CatalogEmpty('Empty catalog: a Computation must be run')

        for ob in related:
            obj = ob.getObject()
            text = ILearningString(obj).learningString()
  
            self.learned_objs.append(obj)
            yield text



    def _nearers_catalog(self,vectorizer,text,clustid):
        try:
            relatedcorpus =  self._iterator_catalog_related_objects(clustid)
            corpus = vectorizer.transform(relatedcorpus)
        except CatalogEmpty:
            return []

        nears = nearers(text,corpus)
        ordered = [ (dist,self.learned_objs[num])  for dist,num in sorted(nears) ]

        return ordered


    def test_predict(self, vectorizer,corpus):
        clustid = self.predict(corpus)[0]

        nears = self._nearers_catalog(vectorizer, corpus, clustid)

        r = "RelatedObjects with clustering predict\n Cluster id: {0}\n Related distance: {1}"
        return r.format(clustid,nears)

